## 리팩터링 2판 4장 - 테스트 구축하기

### 적용 방식

- 책에서는 mocka 테스트 프레임워크를 사용하지만 실습은 Jest를 사용했습니다.
    
    이유는 익숙한 환경에서 테스트 구조를 구성해보고 싶었습니다. 또한, 기본적인 설정이 간단하고 테스트 유틸이 mocka와 크게 이질적이지 않아서 적용하는 것에 큰 무리가 없을 것이라고 판단했습니다.
    

### 챕터 요약

- 리팩터링 하기 전에는 반드시 기존 동작을 보장해주는 테스트를 먼저 마련해야 한다.
- 테스트 코드가 제대로 작동하는지 확인하기 위해 의도적으로 오류를 주입해 테스트 자체를 검증해야 한다.
- 테스트 코드에서도 중복은 개선의 신호이며, 리팩토링 대상이 된다.
- 일반적으로 it 구문 하나당 검증(assertion)도 하나만 포함하는 것이 좋다. 실패 시 원인 파악이 쉽기 때문이다.
- 문제가 발생할 가능성이 높은 경계 조건을 고려해서 중점적으로 테스트해야 한다.
    
    이 과정에서 비즈니스 로직의 특이 케이스나 정책의 허점을 발견할 수 있다.
    

### 기억에 남는 부분

```tsx
  it("shortFall", () => {
    const asia = new Province(sampleProvinceData());
    expect(asia.shortfall).toEqual(5);
  });

  it("profit", () => {
    const asia = new Province(sampleProvinceData());
    expect(asia.profit).toEqual(230);
  });
```

```tsx
const asia = new Province(sampleProvinceData());
```

- 해당 부분은 테스트끼리 상호작용하게 되는 공유 픽스처를 생성하는 원인이 된다.
- `const` 키워드는 asia를 가르키는 “참조”가 상수임을 뜻한다. → 나중에 공유 객체의 값을 수정하면 픽스처를 사용하는 또 다른 테스트가 실패할 수 있다. → 테스트 간의 독립성을 해친다. →  `beforeEach`로 매번 생성한다.
- 즉, 테스트의 독립성 보장을 위해 `beforeEach`를 사용해 **테스트마다 새로운 인스턴스를 생성**하는 것이 권장된다.

### 회고

- 테스트 코드의 신뢰성을 높이기 위해 일시적으로 오류를 주입해 테스트 자체를 검증하는 전략이 인상 깊었습니다. 평소 테스트가 통과하면 그대로 넘어갔는데, 테스트 코드 자체도 의심해봐야 한다는 관점이 생겼습니다.
- 테스트는 단순히 모든 public 메서드를 커버하는 것이 아니라, 위험 요인을 우선 고려해야 한다는 점이 인사이트였습니다. 테스트의 궁극적인 목적은 지금 혹은 미래에 발생할 수 있는 오류를 빠르게 감지하는 것이라는 점을 알게되었습니다.
- 실무에서는 보통 함수형 코드 스타일을 많이 접하다 보니 클래스 기반 구조에 대한 이해가 부족했는데, 이번 실습을 통해 TypeScript와 클래스를 함께 다루면서 공부하는 계기가 되고 있습니다.
시작하기 전에 따라치는 실습에 대한 우려를 했었는데, 테스트를 작성하고 타입스크립트 + 클래스 구조를 다뤄보는 과정에서 얻는 것이 있어 걱정과 달리 좋은 학습 경험이 되고 있습니다.
    

### 생각해볼 점

- getter/setter 사용에 대한 고민
getter/setter는 객체 지향 패턴에서는 익숙한 구조로 알고 있지만, JS/TS에서는 예측 어려운 사이드 이펙트나 디버깅 난이도 문제로 Airbnb 스타일 가이드에서 사용을 지양하는 것을 권장하는 것으로 알고있어요.
저는 계산된 값을 외부에 명확하게 노출해야 하는 경우에는 읽기 전용 getter를 사용하는 것이 가독성과 의도 전달에 더 좋다고 생각합니다.
이번 실습의 예제 수준에서는 사이드 이펙트를 걱정할 정도는 아니라고 판단되어 예제 코드에 따라 getter를 그대로 사용했지만, 실습하기 전에는 써야하나 고민이 있었습니다.
다른분들도 비슷한 고민을 하셨는지 궁금합니당 🤔